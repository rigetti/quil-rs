use pyo3::{prelude::*, types::PyDict, wrap_pymodule};

use crate::expression;
// use crate::instruction;
// use crate::program;
// use crate::validation;
// use crate::units;
use crate::waveform;

pub(crate) mod errors;

#[pymodule]
#[pyo3(name = "_quil")]
fn init_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(expression::init_submodule))?;
    m.add_wrapped(wrap_pymodule!(waveform::init_submodule))?;

    let py = m.py();
    let sys = PyModule::import(py, "sys")?;
    let sys_modules: Bound<'_, PyDict> = sys.getattr("modules")?.downcast_into()?;
    sys_modules.set_item("quil.waveforms", m.getattr("waveforms")?)?;
    sys_modules.set_item("quil.expression", m.getattr("expression")?)?;
    Ok(())
}

/*
create_init_submodule! {
    submodules: [
        "expression": expression::init_submodule,
        "instructions": instruction::init_submodule,
        "program": program::init_submodule,
        "validation": validation::init_submodule,
        "waveforms": waveforms::init_submodule
    ],
}

/// Implement `to_quil` and `to_quil_or_debug` methods for wrapper types whose inner type
/// implements [`Quil`](quil_rs::quil::Quil).
#[macro_export]
macro_rules! impl_to_quil {
    ($name: ident) => {
        #[pyo3::pymethods]
        impl $name {
            pub fn to_quil(&self) -> pyo3::PyResult<String> {
                quil_rs::quil::Quil::to_quil(rigetti_pyo3::PyWrapper::as_inner(self))
                    .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
            }

            pub fn to_quil_or_debug(&self) -> String {
                quil_rs::quil::Quil::to_quil_or_debug(rigetti_pyo3::PyWrapper::as_inner(self))
            }
        }
    };
}
*/

/// Implements pickling for an instruction by implementing __getstate__ and __reduce__.
///
/// The program is serialized using [`Quil`](quil_rs::quil::Quil), which means pickling can fail if
/// `to_quil()` raises an error (e.g. because the instruction contains placeholders).
///
/// To correctly implement __reduce__, an additional `_from_state` method is added to the class.
///
/// See [Python's __reduce__ documentation](https://docs.python.org/3/library/pickle.html#object.__reduce__)
#[macro_export]
macro_rules! impl_pickle_for_instruction {
    ($name: ident) => {
        #[pyo3::pymethods]
        impl $name {
            // This will raise an error if the instruction contains any unresolved
            // placeholders. This is because they can't be converted to valid quil,
            // nor can they be serialized and deserialized in a consistent
            // way.
            pub fn __getstate__(
                &self,
                py: pyo3::Python<'_>,
            ) -> pyo3::PyResult<pyo3::Py<pyo3::types::PyBytes>> {
                use pyo3::IntoPy;
                Ok(pyo3::types::PyBytes::new(py, self.to_quil()?.as_bytes()).into_py(py))
            }

            // __reduce__ must return a tuple containing the necessary components to successfully
            // construct a class instance.
            //
            // In this case, we initialize we return the callable _from_state with the state
            // generated by __getstate__ to reconstruct the instruction.
            fn __reduce__<'py>(
                &'py self,
                py: pyo3::Python<'py>,
            ) -> pyo3::PyResult<&'py pyo3::PyAny> {
                // TODO: IntoPy is deprecated; replace with IntoPyObject
                use pyo3::IntoPy;
                let callable = py.get_type::<Self>().getattr("_from_state")?;
                let state = self.__getstate__(py)?;
                let args = pyo3::types::PyTuple::new(py, &[state.into_py(py)]);
                Ok(pyo3::types::PyTuple::new(py, &[callable, args]))
            }

            // __reduce__ must return a callable with any necessary arguments to initialize the
            // class instance. This is often done with __new__, but because we define class
            // specific parameters in __new__, and field access patterns differ between
            // instruction types (e.g. enums versus data structs), we can't use __new__ in a
            // generic enough way for this macro. As an alternative, we use the serialized state
            // from __getstate__ to initialize a copy of the instance.
            #[staticmethod]
            pub fn _from_state(
                py: pyo3::Python<'_>,
                state: &pyo3::types::PyBytes,
            ) -> pyo3::PyResult<Self> {
                let input = std::str::from_utf8(state.as_bytes())?;
                let instruction = $crate::instruction::PyInstruction::parse(input)?;
                instruction.inner(py)?.extract(py)
            }
        }
    };
}

#[macro_export]
macro_rules! repr {
    () => {};
    
    // Terminal rule to turn processed fields into a format expression.
    (@f ($cls:ident, $slf:ident, $fmt:expr, [$($fields:tt)*]); ()) => {
        format!(concat!( "{}(", $fmt, ")" ), $cls, $($fields)*)
    };
    
    // matches repr!( @f (cls, slf, 'name1={}', [name1]); (name2, name3, name4) )
    // outputs repr!( @f (cls, slf, 'name1={}, name2={}', [name1, name2]); (name3, name4) )
    (@f ($cls:ident, $slf:ident, $fmt:expr, [$($fields:tt)*]); ($field:ident, $($tail:tt)*)) => {
        repr!(@f 
            ( $cls, $slf, concat!($fmt, ", ", stringify!($field), "={}"), [$($fields)* $slf.$field,] );
            ($($tail)*)
        )
    };

    (@x $slf:ident, $exp:expr) => { $slf.$exp };
    (@as_expr $e:expr) => { $e };

    ($slf:ident()) => {
        {
            let class_name: Bound<'_, PyString> = $slf.get_type().qualname()?;
            Ok( format!("{class_name}()") ) 
        }
    };
    
    ($slf:ident( $($fields:tt)* )) => {
        {
            let class_name: Bound<'_, PyString> = $slf.get_type().qualname()?;
            let _slf = $slf.borrow();
            Ok( repr!(@f (class_name, _slf, "", []); ($($fields)*,)) )
        }
    };
}

#[macro_export]
macro_rules! py_wrap_error {
    ($module: expr, $rust: ty, $python: ident, $base: ty) => {
        pyo3::create_exception!($module, $python, $base);

        impl std::convert::From<$rust> for pyo3::PyErr {
            fn from(err: $rust) -> pyo3::PyErr {
                <$python>::new_err(err.to_string())
            }
        }
    };
}
