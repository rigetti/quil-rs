use pyo3::{prelude::*, types::PyDict, wrap_pymodule};

use crate::expression;
use crate::instruction;
use crate::program;
use crate::validation;
use crate::waveform;

pub(crate) mod errors;

#[pymodule]
#[pyo3(name = "_quil")]
fn init_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    use crate::quil_py::errors;

    let py = m.py();

    m.add_wrapped(wrap_pymodule!(expression::init_submodule))?;
    m.add_wrapped(wrap_pymodule!(instruction::init_submodule))?;
    m.add_wrapped(wrap_pymodule!(program::init_submodule))?;
    m.add_wrapped(wrap_pymodule!(validation::init_submodule))?;
    m.add_wrapped(wrap_pymodule!(waveform::init_submodule))?;

    m.add("QuilError", py.get_type::<errors::QuilError>())?;
    m.add("ToQuilError", py.get_type::<errors::ToQuilError>())?;

    let sys = PyModule::import(py, "sys")?;
    let sys_modules: Bound<'_, PyDict> = sys.getattr("modules")?.downcast_into()?;
    sys_modules.set_item("quil.waveforms", m.getattr("waveforms")?)?;
    sys_modules.set_item("quil.expression", m.getattr("expression")?)?;
    sys_modules.set_item("quil.instructions", m.getattr("instructions")?)?;
    sys_modules.set_item("quil.program", m.getattr("program")?)?;

    let validation_module = m.getattr("validation")?;
    sys_modules.set_item(
        "quil.validation.identifier",
        validation_module.getattr("identifier")?,
    )?;
    sys_modules.set_item("quil.validation", validation_module)?;
    Ok(())
}

/// Add Python `to_quil` and `to_quil_or_debug` methods
/// for types that implements [`Quil`](quil_rs::quil::Quil).
#[macro_export]
macro_rules! impl_to_quil {
    ($name: ident) => {
        #[pyo3::pymethods]
        impl $name {
            #[pyo3(name = "to_quil")]
            fn py_to_quil(&self) -> pyo3::PyResult<String> {
                Ok(self.to_quil()?)
            }

            #[pyo3(name = "to_quil_or_debug")]
            fn py_to_quil_or_debug(&self) -> String {
                self.to_quil_or_debug()
            }
        }
    };
}

#[macro_export]
macro_rules! impl_repr {
    ($name: ident) => {
        #[pyo3::pymethods]
        impl $name {
            fn __repr__(&self) -> String {
                format!("{self:?}")
            }
        }
    };
}

/* TODO
/// Implements pickling for an instruction by implementing __getstate__ and __reduce__.
///
/// The program is serialized using [`Quil`](quil_rs::quil::Quil), which means pickling can fail if
/// `to_quil()` raises an error (e.g. because the instruction contains placeholders).
///
/// To correctly implement __reduce__, an additional `_from_state` method is added to the class.
///
/// See [Python's __reduce__ documentation](https://docs.python.org/3/library/pickle.html#object.__reduce__)
#[macro_export]
macro_rules! impl_pickle_for_instruction {
    ($name: ident) => {
        #[pyo3::pymethods]
        impl $name {
            // This will raise an error if the instruction contains any unresolved
            // placeholders. This is because they can't be converted to valid quil,
            // nor can they be serialized and deserialized in a consistent
            // way.
            pub fn __getstate__(
                &self,
                py: pyo3::Python<'_>,
            ) -> pyo3::PyResult<pyo3::Py<pyo3::types::PyBytes>> {
                use pyo3::IntoPy;
                Ok(pyo3::types::PyBytes::new(py, self.to_quil()?.as_bytes()).into_py(py))
            }

            // __reduce__ must return a tuple containing the necessary components to successfully
            // construct a class instance.
            //
            // In this case, we initialize we return the callable _from_state with the state
            // generated by __getstate__ to reconstruct the instruction.
            fn __reduce__<'py>(
                &'py self,
                py: pyo3::Python<'py>,
            ) -> pyo3::PyResult<&'py pyo3::PyAny> {
                // TODO: IntoPy is deprecated; replace with IntoPyObject
                use pyo3::IntoPy;
                let callable = py.get_type::<Self>().getattr("_from_state")?;
                let state = self.__getstate__(py)?;
                let args = pyo3::types::PyTuple::new(py, &[state.into_py(py)]);
                Ok(pyo3::types::PyTuple::new(py, &[callable, args]))
            }

            // __reduce__ must return a callable with any necessary arguments to initialize the
            // class instance. This is often done with __new__, but because we define class
            // specific parameters in __new__, and field access patterns differ between
            // instruction types (e.g. enums versus data structs), we can't use __new__ in a
            // generic enough way for this macro. As an alternative, we use the serialized state
            // from __getstate__ to initialize a copy of the instance.
            #[staticmethod]
            pub fn _from_state(
                py: pyo3::Python<'_>,
                state: &pyo3::types::PyBytes,
            ) -> pyo3::PyResult<Self> {
                let input = std::str::from_utf8(state.as_bytes())?;
                let instruction = $crate::instruction::PyInstruction::parse(input)?;
                instruction.inner(py)?.extract(py)
            }
        }
    };
}
*/
