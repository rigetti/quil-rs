# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import quil.expression
import typing
from enum import Enum

class Arithmetic:
    @property
    def operator(self) -> ArithmeticOperator: ...
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def source(self) -> ArithmeticOperand: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, operator:ArithmeticOperator, destination:MemoryReference, source:ArithmeticOperand) -> Arithmetic: ...
    def __getnewargs__(self) -> tuple[ArithmeticOperator, MemoryReference, ArithmeticOperand]: ...

class ArithmeticOperand:
    def __getnewargs__(self) -> tuple[int | float | MemoryReference]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class LiteralInteger(ArithmeticOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0:builtins.int) -> ArithmeticOperand.LiteralInteger: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class LiteralReal(ArithmeticOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.float) -> ArithmeticOperand.LiteralReal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class MemoryReference(ArithmeticOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> MemoryReference: ...
        def __new__(cls, _0:MemoryReference) -> ArithmeticOperand.MemoryReference: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class AttributeValue:
    def __getnewargs__(self) -> tuple[str | Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class String(AttributeValue):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> AttributeValue.String: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Expression(AttributeValue):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Expression: ...
        def __new__(cls, _0:Expression) -> AttributeValue.Expression: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class BinaryLogic:
    @property
    def operator(self) -> BinaryOperator: ...
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def source(self) -> BinaryOperand: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, operator:BinaryOperator, destination:MemoryReference, source:BinaryOperand) -> BinaryLogic: ...
    def __getnewargs__(self) -> tuple[BinaryOperator, MemoryReference, BinaryOperand]: ...

class Calibration:
    @property
    def identifier(self) -> CalibrationIdentifier: ...
    @property
    def instructions(self) -> builtins.list[Instruction]: ...
    @property
    def name(self) -> builtins.str:
        r"""
        The name that identifies this `Calibration`.
        """
    @property
    def parameters(self) -> builtins.list[Expression]:
        r"""
        The list of parameters that this `Calibration` will expand into.
        """
    @property
    def qubits(self) -> builtins.list[Qubit]:
        r"""
        The list of `Qubit`s that this `Calibration` will expand into.
        """
    @property
    def modifiers(self) -> builtins.list[GateModifier]:
        r"""
        The list of `GateModifier`s that this `Calibration` will expand into.
        """
    @identifier.setter
    def identifier(self, value: CalibrationIdentifier) -> None: ...
    @instructions.setter
    def instructions(self, value: builtins.list[Instruction]) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, identifier:CalibrationIdentifier, instructions:typing.Sequence[Instruction]) -> Calibration:
        r"""
        Builds a new calibration definition.
        """
    def __getnewargs__(self) -> tuple[CalibrationIdentifier, builtins.list[Instruction]]: ...

class CalibrationIdentifier:
    r"""
    Unique identifier for a calibration definition within a program
    """
    @property
    def modifiers(self) -> builtins.list[GateModifier]:
        r"""
        The modifiers applied to the gate
        """
    @property
    def name(self) -> builtins.str:
        r"""
        The name of the gate
        """
    @property
    def parameters(self) -> builtins.list[Expression]:
        r"""
        The parameters of the gate - these are the variables in the calibration definition
        """
    @property
    def qubits(self) -> builtins.list[Qubit]:
        r"""
        The qubits on which the gate is applied
        """
    @modifiers.setter
    def modifiers(self, value: builtins.list[GateModifier]) -> None:
        r"""
        The modifiers applied to the gate
        """
    @name.setter
    def name(self, value: builtins.str) -> None:
        r"""
        The name of the gate
        """
    @parameters.setter
    def parameters(self, value: builtins.list[Expression]) -> None:
        r"""
        The parameters of the gate - these are the variables in the calibration definition
        """
    @qubits.setter
    def qubits(self, value: builtins.list[Qubit]) -> None:
        r"""
        The qubits on which the gate is applied
        """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, name:builtins.str, parameters:typing.Sequence[Expression], qubits:typing.Sequence[Qubit], modifiers:typing.Sequence[GateModifier]) -> CalibrationIdentifier:
        r"""
        Builds a new calibration identifier.
        
        Raises an error if the given name isn't a valid Quil identifier.
        """
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[Expression], builtins.list[Qubit], builtins.list[GateModifier]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Call:
    r"""
    A call instruction with a name and arguments.
    
    An instruction that calls an external function declared with a `PRAGMA EXTERN` instruction.
    These calls are generally specific to a particular hardware or virtual machine backend.
    
    For further detail, see:
    
    * [Other instructions and Directives](https://github.com/quil-lang/quil/blob/master/rfcs/extern-call.md) in the Quil specification.
    * [EXTERN / CALL RFC](https://github.com/quil-lang/quil/blob/master/rfcs/extern-call.md)
    * [quil#87](https://github.com/quil-lang/quil/issues/87)
    
    Also see [`ExternSignature`].
    """
    @property
    def name(self) -> builtins.str: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def py_arguments(self) -> builtins.list[CallArgument]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str, arguments:typing.Sequence[CallArgument]) -> Call:
        r"""
        Create a new call instruction with resolved arguments.
        This will validate the name as a user identifier.
        """
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[CallArgument]]: ...

class CallArgument:
    r"""
    A parsed, but unresolved call argument. This may be resolved into a [`ResolvedCallArgument`]
    with the appropriate [`ExternSignature`]. Resolution is required for building the
    [`crate::Program`] memory graph.
    """
    def __getnewargs__(self) -> tuple[str | MemoryReference | complex]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Identifier(CallArgument):
        r"""
        A reference to a declared memory location. Note, this may be resolved to either
        a scalar or vector. In the former case, the assumed index is 0.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> CallArgument.Identifier: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class MemoryReference(CallArgument):
        r"""
        A reference to a memory location. This may be resolved to a scalar.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> MemoryReference: ...
        def __new__(cls, _0:MemoryReference) -> CallArgument.MemoryReference: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Immediate(CallArgument):
        r"""
        An immediate value. This may be resolved to a non-mutable scalar.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.complex: ...
        def __new__(cls, _0:builtins.complex) -> CallArgument.Immediate: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class CallError(builtins.QuilError):
    r"""
    Errors that may occur when initializing a ``Call``.
    """
    ...

class Capture:
    @property
    def blocking(self) -> builtins.bool: ...
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def memory_reference(self) -> MemoryReference: ...
    @property
    def waveform(self) -> WaveformInvocation: ...
    @blocking.setter
    def blocking(self, value: builtins.bool) -> None: ...
    @frame.setter
    def frame(self, value: FrameIdentifier) -> None: ...
    @memory_reference.setter
    def memory_reference(self, value: MemoryReference) -> None: ...
    @waveform.setter
    def waveform(self, value: WaveformInvocation) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, blocking:builtins.bool, frame:FrameIdentifier, memory_reference:MemoryReference, waveform:WaveformInvocation) -> Capture: ...
    def __getnewargs__(self) -> tuple[builtins.bool, FrameIdentifier, MemoryReference, WaveformInvocation]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class CircuitDefinition:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[builtins.str]: ...
    @property
    def qubit_variables(self) -> builtins.list[builtins.str]: ...
    @property
    def instructions(self) -> builtins.list[Instruction]: ...
    @name.setter
    def name(self, value: builtins.str) -> None: ...
    @parameters.setter
    def parameters(self, value: builtins.list[builtins.str]) -> None: ...
    @qubit_variables.setter
    def qubit_variables(self, value: builtins.list[builtins.str]) -> None: ...
    @instructions.setter
    def instructions(self, value: builtins.list[Instruction]) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, name:builtins.str, parameters:typing.Sequence[builtins.str], qubit_variables:typing.Sequence[builtins.str], instructions:typing.Sequence[Instruction]) -> CircuitDefinition: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[builtins.str], builtins.list[builtins.str], builtins.list[Instruction]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Comparison:
    @property
    def operator(self) -> ComparisonOperator: ...
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def lhs(self) -> MemoryReference: ...
    @property
    def rhs(self) -> ComparisonOperand: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, operator:ComparisonOperator, destination:MemoryReference, lhs:MemoryReference, rhs:ComparisonOperand) -> Comparison: ...
    def __getnewargs__(self) -> tuple[ComparisonOperator, MemoryReference, MemoryReference, ComparisonOperand]: ...

class ComparisonOperand:
    def __getnewargs__(self) -> tuple[int | float | MemoryReference]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class LiteralInteger(ComparisonOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0:builtins.int) -> ComparisonOperand.LiteralInteger: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class LiteralReal(ComparisonOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.float) -> ComparisonOperand.LiteralReal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class MemoryReference(ComparisonOperand):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> MemoryReference: ...
        def __new__(cls, _0:MemoryReference) -> ComparisonOperand.MemoryReference: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class Convert:
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def source(self) -> MemoryReference: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, destination:MemoryReference, source:MemoryReference) -> Convert: ...
    def __getnewargs__(self) -> tuple[MemoryReference, MemoryReference]: ...

class Declaration:
    @property
    def name(self) -> builtins.str: ...
    @property
    def size(self) -> Vector: ...
    @property
    def sharing(self) -> typing.Optional[Sharing]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, name:builtins.str, size:Vector, sharing:typing.Optional[Sharing]) -> Declaration: ...
    def __getnewargs__(self) -> tuple[builtins.str, Vector, typing.Optional[Sharing]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Delay:
    @property
    def duration(self) -> Expression: ...
    @property
    def frame_names(self) -> builtins.list[builtins.str]: ...
    @property
    def qubits(self) -> builtins.list[Qubit]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, duration:Expression, frame_names:typing.Sequence[builtins.str], qubits:typing.Sequence[Qubit]) -> Delay: ...
    def __getnewargs__(self) -> tuple[Expression, builtins.list[builtins.str], builtins.list[Qubit]]: ...

class Exchange:
    @property
    def left(self) -> MemoryReference: ...
    @property
    def right(self) -> MemoryReference: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, left:MemoryReference, right:MemoryReference) -> Exchange: ...
    def __getnewargs__(self) -> tuple[MemoryReference, MemoryReference]: ...

class ExternError(builtins.QuilError):
    r"""
    Errors that may occur when initializing or validating a ``PRAGMA EXTERN`` instruction.
    """
    ...

class ExternParameter:
    r"""
    An extern parameter with a name, mutability, and data type.
    """
    @property
    def name(self) -> builtins.str:
        r"""
        The name of the parameter. This must be a valid user identifier.
        """
    @property
    def mutable(self) -> builtins.bool:
        r"""
        Whether the parameter is mutable.
        """
    @property
    def data_type(self) -> ExternParameterType:
        r"""
        The data type of the parameter.
        """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str, mutable:builtins.bool, data_type:ExternParameterType) -> ExternParameter:
        r"""
        Create a new extern parameter. This will fail if the parameter name
        is not a valid user identifier.
        """
    def __getnewargs__(self) -> tuple[builtins.str, builtins.bool, ExternParameterType]: ...

class ExternParameterType:
    r"""
    A parameter type within an extern signature.
    """
    def __getnewargs__(self) -> tuple[ScalarType | Vector]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Scalar(ExternParameterType):
        r"""
        A scalar parameter, which may accept a memory reference or immediate value.
        
        For instance `PRAGMA EXTERN foo "(bar : INTEGER)"`.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> ScalarType: ...
        def __new__(cls, _0:ScalarType) -> ExternParameterType.Scalar: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class FixedLengthVector(ExternParameterType):
        r"""
        A fixed-length vector, which must accept a memory region name of the appropriate
        length and data type.
        
        For instance `PRAGMA EXTERN foo "(bar : INTEGER[2])"`.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Vector: ...
        def __new__(cls, _0:Vector) -> ExternParameterType.FixedLengthVector: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class VariableLengthVector(ExternParameterType):
        r"""
        A variable-length vector, which must accept a memory region name of the appropriate
        data type.
        
        For instance `PRAGMA EXTERN foo "(bar : INTEGER[])"`.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> ScalarType: ...
        def __new__(cls, _0:ScalarType) -> ExternParameterType.VariableLengthVector: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class ExternSignature:
    r"""
    An extern signature with a return type and parameters.
    
    The signature of a ``PRAGMA EXTERN`` instruction.
    This signature is defined by a list of ``ExternParameter``s and an optional return type.
    See the [Quil Specification](https://github.com/quil-lang/quil/blob/7f532c7cdde9f51eae6abe7408cc868fba9f91f6/specgen/spec/sec-other.s)
    for details on how these signatures are formed.
    """
    @property
    def return_type(self) -> typing.Optional[ScalarType]:
        r"""
        The return type of the extern signature, if any.
        """
    @property
    def parameters(self) -> builtins.list[ExternParameter]:
        r"""
        The parameters of the extern signature.
        """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, return_type:typing.Optional[ScalarType], parameters:typing.Sequence[ExternParameter]) -> ExternSignature:
        r"""
        Create a new extern signature.
        """
    def __getnewargs__(self) -> tuple[typing.Optional[ScalarType], builtins.list[ExternParameter]]: ...

class Fence:
    @property
    def qubits(self) -> builtins.list[Qubit]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, qubits:typing.Sequence[Qubit]) -> Fence: ...
    def __getnewargs__(self) -> tuple[builtins.list[Qubit]]: ...

class FrameDefinition:
    @property
    def identifier(self) -> FrameIdentifier: ...
    @property
    def attributes(self) -> builtins.dict[builtins.str, AttributeValue]: ...
    @identifier.setter
    def identifier(self, value: FrameIdentifier) -> None: ...
    @attributes.setter
    def attributes(self, value: builtins.dict[builtins.str, AttributeValue]) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, identifier:FrameIdentifier, attributes:typing.Mapping[builtins.str, AttributeValue]) -> FrameDefinition: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, builtins.dict[builtins.str, AttributeValue]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class FrameIdentifier:
    @property
    def name(self) -> builtins.str: ...
    @property
    def qubits(self) -> builtins.list[Qubit]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, name:builtins.str, qubits:typing.Sequence[Qubit]) -> FrameIdentifier: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[Qubit]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Gate:
    r"""
    A struct encapsulating all the properties of a Quil Quantum Gate.
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[Expression]: ...
    @property
    def qubits(self) -> builtins.list[Qubit]: ...
    @property
    def modifiers(self) -> builtins.list[GateModifier]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def dagger(self) -> Gate:
        r"""
        Return a copy of the ``Gate`` with the ``DAGGER`` modifier added to it.
        """
    def controlled(self, control_qubit:Qubit) -> Gate:
        r"""
        Return a copy of the ``Gate`` with the ``CONTROLLED`` modifier added to it.
        """
    def forked(self, fork_qubit:Qubit, alt_params:typing.Sequence[Expression]) -> Gate:
        r"""
        Return a copy of the ``Gate`` with the ``FORKED`` modifier added to it.
        
        Raises a ``GateError`` if the number of provided alternate parameters
        don't equal the number of existing parameters.
        """
    def to_unitary(self, n_qubits:builtins.int) -> numpy.typing.NDArray[numpy.complex128]:
        r"""
        Get the matrix resulting from lifting this ``Gate``
        to the full `n_qubits`-qubit Hilbert space.
        
        Raises a ``GateError`` if any of the parameters of this ``Gate`` are non-constant,
        if any of the ``Qubit``s are variable,
        if the name of this ``Gate`` is unknown,
        or if there are an unexpected number of parameters.
        
        # Notes
        
        A previous version of this library called this `to_unitary_mut`,
        and modified the ``Gate`` when called.
        This is no longer possible, as it would modify the ``Gate``'s hash,
        leading to confusing bugs.
        ``Gate``s, as well as all other hashable classes, are immutable from Python.
        
        # Bugs
        
        Supplying `n_qubits` as `0` will raise an unspecified exception;
        other invalid input parameters may silently return an invalid result.
        """
    def __new__(cls, name:builtins.str, parameters:typing.Sequence[Expression], qubits:typing.Sequence[Qubit], modifiers:typing.Sequence[GateModifier]) -> Gate: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[Expression], builtins.list[Qubit], builtins.list[GateModifier]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class GateDefinition:
    r"""
    A struct encapsulating a quil Gate Definition
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[builtins.str]: ...
    @property
    def specification(self) -> GateSpecification: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str, parameters:typing.Sequence[builtins.str], specification:GateSpecification) -> GateDefinition: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[builtins.str], GateSpecification]: ...

class GateError(builtins.QuilError):
    r"""
    Errors that may occur when performing operations on a ``Gate``.
    """
    ...

class GateSpecification:
    r"""
    An enum representing a the specification of a [`GateDefinition`] for a given [`GateType`]
    """
    def __getnewargs__(self) -> tuple[list[list[Expression]] | list[int] | GateType.PauliSum]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Matrix(GateSpecification):
        r"""
        A matrix of [`Expression`]s representing a unitary operation for a [`GateType::Matrix`].
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.list[Expression]]: ...
        def __new__(cls, _0:typing.Sequence[typing.Sequence[Expression]]) -> GateSpecification.Matrix: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Permutation(GateSpecification):
        r"""
        A vector of integers that defines the permutation used for a [`GateType::Permutation`]
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.int]: ...
        def __new__(cls, _0:typing.Sequence[builtins.int]) -> GateSpecification.Permutation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class PauliSum(GateSpecification):
        r"""
        A Hermitian operator specified as a Pauli sum, a sum of combinations of Pauli operators,
        used for a [`GateType::PauliSum`]
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> PauliSum: ...
        def __new__(cls, _0:PauliSum) -> GateSpecification.PauliSum: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class Include:
    @property
    def filename(self) -> builtins.str: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, filename:builtins.str) -> Include: ...
    def __getnewargs__(self) -> tuple[builtins.str]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Instruction:
    r"""
    A Quil instruction.
    
    Each variant (for Python users, each nested subclass)
    corresponds to a possible type of Quil instruction,
    which is accessible as a member within the variant.
    
    # Python Users
    
    The subclasses of this class are class attributes defined on it,
    and can be used to "wrap" instructions when they should be stored together.
    In particular, they are *NOT* the instruction classes you'd typically create,
    and instances of instruction classes are *NOT* subclasses of this class:
    
    ```python
    >>> from quil.instructions import Instruction, Gate, Qubit
    >>> issubclass(Instruction.Gate, Instruction)
    True
    >>> issubclass(Gate, Instruction)
    False
    >>> g = Gate("X", (), (Qubit.Fixed(0),), ())
    >>> isinstance(g, Gate)
    True
    >>> isinstance(g, Instruction.Gate)
    False
    >>> g_instr = Instruction.Gate(g)
    >>> isinstance(g_instr, Gate)
    False
    >>> isinstance(g_instr, Instruction.Gate)
    True
    >>> isinstance(g_instr._0, Gate)
    True
    >>> g_instr._0 == g
    True
    ```
    
    The point of this class is to wrap different kinds of instructions
    when stored together in a collection, all of which are of type `Instruction`.
    You can check for different instruction variants and destructure them using `match`:
    
    ```python
    match g_instr:
        case Instruction.Gate(gate):
            assert isinstance(gate, Gate)
        case Instruction.Wait() | Instruction.Nop():
            # note the `()` -- these aren't like Python's enumerations!
    ```
    """
    def is_quil_t(self) -> builtins.bool:
        r"""
        Returns true if the instruction is a Quil-T instruction.
        """
    def __getnewargs__(self) -> tuple[()] | tuple[Calibration | Arithmetic | BinaryLogic | Call | Capture | CircuitDefinition | Comparison | Convert | Declaration | Delay | Exchange | Fence | FrameDefinition | Gate | GateDefinition | Include | Jump | JumpUnless | JumpWhen | Label | Load | MeasureCalibrationDefinition | Measurement | Move | Pragma | Pulse | RawCapture | Reset | SetFrequency | SetPhase | SetScale | ShiftFrequency | ShiftPhase | Store | SwapPhases | UnaryLogic | WaveformDefinition]: ...
    @staticmethod
    def parse(string:builtins.str) -> Instruction: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Arithmetic(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Arithmetic: ...
        def __new__(cls, _0:Arithmetic) -> Instruction.Arithmetic: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class BinaryLogic(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> BinaryLogic: ...
        def __new__(cls, _0:BinaryLogic) -> Instruction.BinaryLogic: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class CalibrationDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Calibration: ...
        def __new__(cls, _0:Calibration) -> Instruction.CalibrationDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Call(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Call: ...
        def __new__(cls, _0:Call) -> Instruction.Call: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Capture(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Capture: ...
        def __new__(cls, _0:Capture) -> Instruction.Capture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class CircuitDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> CircuitDefinition: ...
        def __new__(cls, _0:CircuitDefinition) -> Instruction.CircuitDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Convert(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Convert: ...
        def __new__(cls, _0:Convert) -> Instruction.Convert: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Comparison(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Comparison: ...
        def __new__(cls, _0:Comparison) -> Instruction.Comparison: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Declaration(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Declaration: ...
        def __new__(cls, _0:Declaration) -> Instruction.Declaration: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Delay(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Delay: ...
        def __new__(cls, _0:Delay) -> Instruction.Delay: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Exchange(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Exchange: ...
        def __new__(cls, _0:Exchange) -> Instruction.Exchange: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Fence(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Fence: ...
        def __new__(cls, _0:Fence) -> Instruction.Fence: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class FrameDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> FrameDefinition: ...
        def __new__(cls, _0:FrameDefinition) -> Instruction.FrameDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Gate(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Gate: ...
        def __new__(cls, _0:Gate) -> Instruction.Gate: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class GateDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> GateDefinition: ...
        def __new__(cls, _0:GateDefinition) -> Instruction.GateDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Halt(Instruction):
        __match_args__ = ((),)
        def __new__(cls) -> Instruction.Halt: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Include(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Include: ...
        def __new__(cls, _0:Include) -> Instruction.Include: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Jump(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Jump: ...
        def __new__(cls, _0:Jump) -> Instruction.Jump: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class JumpUnless(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> JumpUnless: ...
        def __new__(cls, _0:JumpUnless) -> Instruction.JumpUnless: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class JumpWhen(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> JumpWhen: ...
        def __new__(cls, _0:JumpWhen) -> Instruction.JumpWhen: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Label(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Label: ...
        def __new__(cls, _0:Label) -> Instruction.Label: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Load(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Load: ...
        def __new__(cls, _0:Load) -> Instruction.Load: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class MeasureCalibrationDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> MeasureCalibrationDefinition: ...
        def __new__(cls, _0:MeasureCalibrationDefinition) -> Instruction.MeasureCalibrationDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Measurement(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Measurement: ...
        def __new__(cls, _0:Measurement) -> Instruction.Measurement: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Move(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Move: ...
        def __new__(cls, _0:Move) -> Instruction.Move: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Nop(Instruction):
        __match_args__ = ((),)
        def __new__(cls) -> Instruction.Nop: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Pragma(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Pragma: ...
        def __new__(cls, _0:Pragma) -> Instruction.Pragma: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Pulse(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Pulse: ...
        def __new__(cls, _0:Pulse) -> Instruction.Pulse: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class RawCapture(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> RawCapture: ...
        def __new__(cls, _0:RawCapture) -> Instruction.RawCapture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Reset(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Reset: ...
        def __new__(cls, _0:Reset) -> Instruction.Reset: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class SetFrequency(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> SetFrequency: ...
        def __new__(cls, _0:SetFrequency) -> Instruction.SetFrequency: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class SetPhase(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> SetPhase: ...
        def __new__(cls, _0:SetPhase) -> Instruction.SetPhase: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class SetScale(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> SetScale: ...
        def __new__(cls, _0:SetScale) -> Instruction.SetScale: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class ShiftFrequency(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> ShiftFrequency: ...
        def __new__(cls, _0:ShiftFrequency) -> Instruction.ShiftFrequency: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class ShiftPhase(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> ShiftPhase: ...
        def __new__(cls, _0:ShiftPhase) -> Instruction.ShiftPhase: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Store(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Store: ...
        def __new__(cls, _0:Store) -> Instruction.Store: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class SwapPhases(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> SwapPhases: ...
        def __new__(cls, _0:SwapPhases) -> Instruction.SwapPhases: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class UnaryLogic(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> UnaryLogic: ...
        def __new__(cls, _0:UnaryLogic) -> Instruction.UnaryLogic: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class WaveformDefinition(Instruction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> WaveformDefinition: ...
        def __new__(cls, _0:WaveformDefinition) -> Instruction.WaveformDefinition: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Wait(Instruction):
        __match_args__ = ((),)
        def __new__(cls) -> Instruction.Wait: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class InstructionError(builtins.QuilError):
    r"""
    Base error type for errors related to ``Instruction`` processing.
    """
    ...

class Jump:
    @property
    def target(self) -> Target: ...
    @target.setter
    def target(self, value: Target) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, target:Target) -> Jump: ...
    def __getnewargs__(self) -> tuple[Target]: ...

class JumpUnless:
    @property
    def target(self) -> Target: ...
    @property
    def condition(self) -> MemoryReference: ...
    @target.setter
    def target(self, value: Target) -> None: ...
    @condition.setter
    def condition(self, value: MemoryReference) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, target:Target, condition:MemoryReference) -> JumpUnless: ...
    def __getnewargs__(self) -> tuple[Target, MemoryReference]: ...

class JumpWhen:
    @property
    def target(self) -> Target: ...
    @property
    def condition(self) -> MemoryReference: ...
    @target.setter
    def target(self, value: Target) -> None: ...
    @condition.setter
    def condition(self, value: MemoryReference) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, target:Target, condition:MemoryReference) -> JumpWhen: ...
    def __getnewargs__(self) -> tuple[Target, MemoryReference]: ...

class Label:
    @property
    def target(self) -> Target: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, target:Target) -> Label: ...
    def __getnewargs__(self) -> tuple[Target]: ...

class Load:
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def source(self) -> builtins.str: ...
    @property
    def offset(self) -> MemoryReference: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, destination:MemoryReference, source:builtins.str, offset:MemoryReference) -> Load: ...
    def __getnewargs__(self) -> tuple[MemoryReference, builtins.str, MemoryReference]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class MeasureCalibrationDefinition:
    @property
    def identifier(self) -> MeasureCalibrationIdentifier: ...
    @property
    def instructions(self) -> builtins.list[Instruction]: ...
    @property
    def qubit(self) -> typing.Optional[Qubit]: ...
    @property
    def parameter(self) -> builtins.str: ...
    @identifier.setter
    def identifier(self, value: MeasureCalibrationIdentifier) -> None: ...
    @instructions.setter
    def instructions(self, value: builtins.list[Instruction]) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, identifier:MeasureCalibrationIdentifier, instructions:typing.Sequence[Instruction]) -> MeasureCalibrationDefinition: ...
    def __getnewargs__(self) -> tuple[MeasureCalibrationIdentifier, builtins.list[Instruction]]: ...

class MeasureCalibrationIdentifier:
    r"""
    A unique identifier for a measurement calibration definition within a program
    """
    @property
    def qubit(self) -> typing.Optional[Qubit]:
        r"""
        The qubit which is the target of measurement, if any
        """
    @property
    def parameter(self) -> builtins.str:
        r"""
        The memory region name to which the measurement result is written
        """
    @qubit.setter
    def qubit(self, value: typing.Optional[Qubit]) -> None:
        r"""
        The qubit which is the target of measurement, if any
        """
    @parameter.setter
    def parameter(self, value: builtins.str) -> None:
        r"""
        The memory region name to which the measurement result is written
        """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, qubit:typing.Optional[Qubit], parameter:builtins.str) -> MeasureCalibrationIdentifier: ...
    def __getnewargs__(self) -> tuple[typing.Optional[Qubit], builtins.str]: ...

class Measurement:
    @property
    def qubit(self) -> Qubit: ...
    @property
    def target(self) -> typing.Optional[MemoryReference]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, qubit:Qubit, target:typing.Optional[MemoryReference]) -> Measurement: ...
    def __getnewargs__(self) -> tuple[Qubit, typing.Optional[MemoryReference]]: ...

class MemoryReference:
    @property
    def name(self) -> builtins.str: ...
    @property
    def index(self) -> builtins.int: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, name:builtins.str, index:builtins.int) -> MemoryReference: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.int]: ...
    @staticmethod
    def parse(string:builtins.str) -> MemoryReference: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Move:
    @property
    def destination(self) -> MemoryReference: ...
    @property
    def source(self) -> ArithmeticOperand: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, destination:MemoryReference, source:ArithmeticOperand) -> Move: ...
    def __getnewargs__(self) -> tuple[MemoryReference, ArithmeticOperand]: ...

class Offset:
    @property
    def offset(self) -> builtins.int: ...
    @property
    def data_type(self) -> ScalarType: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, offset:builtins.int, data_type:ScalarType) -> Offset: ...
    def __getnewargs__(self) -> tuple[builtins.int, ScalarType]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class ParseInstructionError(builtins.InstructionError):
    r"""
    Errors that may occur while parsing an ``Instruction``.
    """
    ...

class ParseMemoryReferenceError(builtins.QuilError):
    r"""
    Errors that may occur while parsing a ``MemoryReference``.
    """
    ...

class PauliSum:
    @property
    def arguments(self) -> builtins.list[builtins.str]: ...
    @property
    def terms(self) -> builtins.list[PauliTerm]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, arguments:typing.Sequence[builtins.str], terms:typing.Sequence[PauliTerm]) -> PauliSum: ...
    def __getnewargs__(self) -> tuple[builtins.list[builtins.str], builtins.list[PauliTerm]]: ...

class PauliTerm:
    @property
    def arguments(self) -> builtins.list[tuple[PauliGate, builtins.str]]: ...
    @property
    def expression(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, arguments:typing.Sequence[tuple[PauliGate, builtins.str]], expression:Expression) -> PauliTerm: ...
    def __getnewargs__(self) -> tuple[builtins.list[tuple[PauliGate, builtins.str]], Expression]: ...

class Pragma:
    @property
    def name(self) -> builtins.str: ...
    @property
    def arguments(self) -> builtins.list[PragmaArgument]: ...
    @property
    def data(self) -> typing.Optional[builtins.str]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, name:builtins.str, arguments:typing.Sequence[PragmaArgument], data:typing.Optional[builtins.str]) -> Pragma: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[PragmaArgument], typing.Optional[builtins.str]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class PragmaArgument:
    def __getnewargs__(self) -> tuple[int | str]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Identifier(PragmaArgument):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> PragmaArgument.Identifier: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Integer(PragmaArgument):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0:builtins.int) -> PragmaArgument.Integer: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class Pulse:
    @property
    def blocking(self) -> builtins.bool: ...
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def waveform(self) -> WaveformInvocation: ...
    @blocking.setter
    def blocking(self, value: builtins.bool) -> None: ...
    @frame.setter
    def frame(self, value: FrameIdentifier) -> None: ...
    @waveform.setter
    def waveform(self, value: WaveformInvocation) -> None: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, blocking:builtins.bool, frame:FrameIdentifier, waveform:WaveformInvocation) -> Pulse: ...
    def __getnewargs__(self) -> tuple[builtins.bool, FrameIdentifier, WaveformInvocation]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Qubit:
    def __getnewargs__(self) -> tuple[int | str | QubitPlaceholder]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Fixed(Qubit):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0:builtins.int) -> Qubit.Fixed: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Placeholder(Qubit):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> QubitPlaceholder: ...
        def __new__(cls, _0:QubitPlaceholder) -> Qubit.Placeholder: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Variable(Qubit):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> Qubit.Variable: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class QubitPlaceholder:
    r"""
    An opaque placeholder for a qubit whose index may be assigned at a later time.
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __lt__(self, other:builtins.object) -> builtins.bool: ...
    def __le__(self, other:builtins.object) -> builtins.bool: ...
    def __gt__(self, other:builtins.object) -> builtins.bool: ...
    def __ge__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls) -> QubitPlaceholder: ...
    def __getnewargs__(self) -> NoReturn:
        r"""
        `QubitPlaceholder`s do not support `pickle` or `deepcopy`.
        Calling this method will raise an error.
        """
    def __repr__(self) -> builtins.str: ...

class RawCapture:
    @property
    def blocking(self) -> builtins.bool: ...
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def duration(self) -> Expression: ...
    @property
    def memory_reference(self) -> MemoryReference: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, blocking:builtins.bool, frame:FrameIdentifier, duration:Expression, memory_reference:MemoryReference) -> RawCapture: ...
    def __getnewargs__(self) -> tuple[builtins.bool, FrameIdentifier, Expression, MemoryReference]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Reset:
    @property
    def qubit(self) -> typing.Optional[Qubit]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, qubit:typing.Optional[Qubit]) -> Reset: ...
    def __getnewargs__(self) -> tuple[typing.Optional[Qubit]]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class SetFrequency:
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def frequency(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame:FrameIdentifier, frequency:Expression) -> SetFrequency: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class SetPhase:
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def phase(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame:FrameIdentifier, phase:Expression) -> SetPhase: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class SetScale:
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def scale(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame:FrameIdentifier, scale:Expression) -> SetScale: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Sharing:
    @property
    def name(self) -> builtins.str: ...
    @property
    def offsets(self) -> builtins.list[Offset]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, name:builtins.str, offsets:typing.Sequence[Offset]) -> Sharing: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.list[Offset]]: ...
    def __repr__(self) -> builtins.str: ...

class ShiftFrequency:
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def frequency(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame:FrameIdentifier, frequency:Expression) -> ShiftFrequency: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class ShiftPhase:
    @property
    def frame(self) -> FrameIdentifier: ...
    @property
    def phase(self) -> Expression: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame:FrameIdentifier, phase:Expression) -> ShiftPhase: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, Expression]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Store:
    @property
    def destination(self) -> builtins.str: ...
    @property
    def offset(self) -> MemoryReference: ...
    @property
    def source(self) -> ArithmeticOperand: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, destination:builtins.str, offset:MemoryReference, source:ArithmeticOperand) -> Store: ...
    def __getnewargs__(self) -> tuple[builtins.str, MemoryReference, ArithmeticOperand]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class SwapPhases:
    @property
    def frame_1(self) -> FrameIdentifier: ...
    @property
    def frame_2(self) -> FrameIdentifier: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, frame_1:FrameIdentifier, frame_2:FrameIdentifier) -> SwapPhases: ...
    def __getnewargs__(self) -> tuple[FrameIdentifier, FrameIdentifier]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Target:
    def __getnewargs__(self) -> tuple[str | TargetPlaceholder]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Fixed(Target):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> Target.Fixed: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Placeholder(Target):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> TargetPlaceholder: ...
        def __new__(cls, _0:TargetPlaceholder) -> Target.Placeholder: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class TargetPlaceholder:
    r"""
    An opaque placeholder for a label whose index may be assigned
    at a later time.
    """
    @property
    def base_label(self) -> builtins.str: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __lt__(self, other:builtins.object) -> builtins.bool: ...
    def __le__(self, other:builtins.object) -> builtins.bool: ...
    def __gt__(self, other:builtins.object) -> builtins.bool: ...
    def __ge__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, base_label:builtins.str) -> TargetPlaceholder: ...

class UnaryLogic:
    @property
    def operator(self) -> UnaryOperator: ...
    @property
    def operand(self) -> MemoryReference: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, operator:UnaryOperator, operand:MemoryReference) -> UnaryLogic: ...
    def __getnewargs__(self) -> tuple[UnaryOperator, MemoryReference]: ...

class Vector:
    @property
    def data_type(self) -> ScalarType: ...
    @property
    def length(self) -> builtins.int: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, data_type:ScalarType, length:builtins.int) -> Vector: ...
    def __getnewargs__(self) -> tuple[ScalarType, builtins.int]: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Waveform:
    @property
    def matrix(self) -> builtins.list[Expression]: ...
    @property
    def parameters(self) -> builtins.list[builtins.str]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, matrix:typing.Sequence[Expression], parameters:typing.Sequence[builtins.str]) -> Waveform: ...

class WaveformDefinition:
    @property
    def name(self) -> builtins.str: ...
    @property
    def definition(self) -> Waveform: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str, definition:Waveform) -> WaveformDefinition: ...
    def __getnewargs__(self) -> tuple[builtins.str, Waveform]: ...

class WaveformInvocation:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.dict[builtins.str, Expression]: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str, parameters:typing.Mapping[builtins.str, Expression]) -> WaveformInvocation: ...
    def __getnewargs__(self) -> tuple[builtins.str, builtins.dict[builtins.str, Expression]]: ...

class ArithmeticOperator(Enum):
    Add = ...
    Subtract = ...
    Divide = ...
    Multiply = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class BinaryOperand(Enum):
    LiteralInteger = ...
    MemoryReference = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class BinaryOperator(Enum):
    And = ...
    Ior = ...
    Xor = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class ComparisonOperator(Enum):
    Equal = ...
    GreaterThanOrEqual = ...
    GreaterThan = ...
    LessThanOrEqual = ...
    LessThan = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class GateModifier(Enum):
    r"""
    An enum of all the possible modifiers on a quil [`Gate`]
    """
    Controlled = ...
    r"""
    The `CONTROLLED` modifier makes the gate take an extra [`Qubit`] parameter as a control
    qubit.
    """
    Dagger = ...
    r"""
    The `DAGGER` modifier does a complex-conjugate transpose on the [`Gate`].
    """
    Forked = ...
    r"""
    The `FORKED` modifier allows an alternate set of parameters to be used based on the state
    of a qubit.
    """

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class PauliGate(Enum):
    I = ...
    X = ...
    Y = ...
    Z = ...

    @staticmethod
    def parse(input:builtins.str) -> PauliGate:
        r"""
        Parse a ``PauliGate`` from a string.
        
        Raises a ``ParseExpressionError`` error if the string isn't a valid Quil expression.
        """
    def __repr__(self) -> builtins.str: ...

class ScalarType(Enum):
    Bit = ...
    Integer = ...
    Octet = ...
    Real = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class UnaryOperator(Enum):
    Neg = ...
    Not = ...

    def to_quil(self) -> builtins.str: ...
    def to_quil_or_debug(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

